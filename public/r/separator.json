{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "separator",
  "type": "registry:component",
  "title": "Separator",
  "description": "An interactive separator with a wobbling string animation. The line bends toward the mouse cursor and oscillates with a satisfying spring effect when released.",
  "dependencies": ["gsap"],
  "files": [
    {
      "path": "registry/new-york/separator/separator.tsx",
      "content": "'use client';\nimport { useRef, useEffect, useCallback } from 'react';\nimport gsap from 'gsap';\n\n// Fixed internal coordinate system for SVG\nconst VIEWBOX_WIDTH = 1000;\nconst VIEWBOX_HEIGHT = 100;\n\ninterface SeparatorProps {\n  /** Base Y position of the line (0-100) */\n  baseY?: number;\n  /** Maximum displacement when mouse hovers */\n  maxDisplacement?: number;\n  /** Height of the hover detection zone in pixels */\n  hoverZoneHeight?: number;\n  /** Stroke width of the line */\n  strokeWidth?: number;\n  /** Damping factor (0-1, lower = more oscillations) */\n  damping?: number;\n  /** Oscillation frequency */\n  frequency?: number;\n  /** Duration of the wobble animation in seconds */\n  duration?: number;\n  /** Additional CSS classes */\n  className?: string;\n}\n\nexport function Separator({\n  baseY = 50,\n  maxDisplacement = 40,\n  hoverZoneHeight = 100,\n  strokeWidth = 2,\n  damping = 0.15,\n  frequency = 8,\n  duration = 1.5,\n  className = '',\n}: SeparatorProps) {\n  const containerRef = useRef<HTMLDivElement | null>(null);\n  const pathRef = useRef<SVGPathElement | null>(null);\n\n  // Animation state refs\n  const stateRef = useRef<{\n    displacement: number;\n    controlX: number;\n    isInsideViewbox: boolean;\n  }>({\n    displacement: 0,\n    controlX: VIEWBOX_WIDTH / 2,\n    isInsideViewbox: false,\n  });\n\n  const wobbleTweenRef = useRef<gsap.core.Tween | null>(null);\n\n  const updatePath = useCallback(() => {\n    if (!pathRef.current) return;\n    const { displacement, controlX } = stateRef.current;\n    const controlY = baseY + displacement;\n    pathRef.current.setAttribute(\n      'd',\n      `M 0 ${baseY} Q ${controlX} ${controlY} ${VIEWBOX_WIDTH} ${baseY}`\n    );\n  }, [baseY]);\n\n  // Start damped oscillation from current displacement\n  const startOscillation = useCallback(() => {\n    // Kill any existing animation\n    if (wobbleTweenRef.current) {\n      wobbleTweenRef.current.kill();\n    }\n\n    const initialDisplacement = stateRef.current.displacement;\n\n    // Don't oscillate if barely displaced\n    if (Math.abs(initialDisplacement) < 1) {\n      stateRef.current.displacement = 0;\n      updatePath();\n      return;\n    }\n\n    // Custom damped sinusoidal oscillation\n    // Formula: A * e^(-damping * t) * cos(frequency * t)\n    // Using cos so it starts at the current displacement\n    const wobbleData = { progress: 0 };\n    const amplitude = initialDisplacement;\n\n    wobbleTweenRef.current = gsap.to(wobbleData, {\n      progress: 1,\n      duration: duration,\n      ease: 'none',\n      onUpdate: () => {\n        // t represents actual elapsed time (0 to duration)\n        const t = wobbleData.progress * duration;\n        // Damped cosine wave: starts at amplitude, oscillates with decay\n        // frequency controls oscillations per second\n        const decay = Math.exp(-damping * frequency * t);\n        const oscillation = Math.cos(frequency * t * Math.PI * 2);\n        stateRef.current.displacement = amplitude * decay * oscillation;\n        updatePath();\n      },\n      onComplete: () => {\n        stateRef.current.displacement = 0;\n        updatePath();\n      },\n    });\n  }, [updatePath, damping, frequency, duration]);\n\n  useEffect(() => {\n    const container = containerRef.current;\n    if (!container) return;\n\n    const handleMouseMove = (e: MouseEvent) => {\n      const rect = container.getBoundingClientRect();\n      const relativeX = e.clientX - rect.left;\n      const relativeY = e.clientY - rect.top;\n\n      // Check if mouse is inside the viewbox\n      const isInside =\n        relativeX >= 0 &&\n        relativeX <= rect.width &&\n        relativeY >= 0 &&\n        relativeY <= rect.height;\n\n      if (isInside) {\n        // Mouse is inside - pull string toward mouse position\n        if (!stateRef.current.isInsideViewbox) {\n          // Just entered the viewbox - kill any running oscillation\n          if (wobbleTweenRef.current) {\n            wobbleTweenRef.current.kill();\n          }\n          stateRef.current.isInsideViewbox = true;\n        }\n\n        // Calculate displacement based on mouse Y position relative to line\n        const lineY = (baseY / 100) * rect.height;\n        const distanceFromLine = relativeY - lineY;\n\n        // Clamp displacement to maxDisplacement\n        const displacement = Math.max(\n          -maxDisplacement,\n          Math.min(\n            maxDisplacement,\n            distanceFromLine * (maxDisplacement / (rect.height / 2))\n          )\n        );\n\n        // Update control point X based on mouse X position (mapped to viewbox coords)\n        stateRef.current.controlX = (relativeX / rect.width) * VIEWBOX_WIDTH;\n        stateRef.current.displacement = displacement;\n        updatePath();\n      } else if (stateRef.current.isInsideViewbox) {\n        // Mouse just left the viewbox - start oscillation from current displacement\n        stateRef.current.isInsideViewbox = false;\n        startOscillation();\n      }\n    };\n\n    const handleMouseLeave = () => {\n      if (stateRef.current.isInsideViewbox) {\n        // Mouse left the container - start oscillation\n        stateRef.current.isInsideViewbox = false;\n        startOscillation();\n      }\n    };\n\n    container.addEventListener('mousemove', handleMouseMove);\n    container.addEventListener('mouseleave', handleMouseLeave);\n\n    return () => {\n      container.removeEventListener('mousemove', handleMouseMove);\n      container.removeEventListener('mouseleave', handleMouseLeave);\n      if (wobbleTweenRef.current) {\n        wobbleTweenRef.current.kill();\n      }\n    };\n  }, [baseY, maxDisplacement, updatePath, startOscillation]);\n\n  // Initialize path on mount\n  useEffect(() => {\n    updatePath();\n  }, [updatePath]);\n\n  return (\n    <div className={`${className}`}>\n      <div\n        ref={containerRef}\n        className={`text-foreground w-full cursor-pointer `}\n        style={{ height: `${hoverZoneHeight}px` }}\n      >\n        <svg\n          height=\"100%\"\n          width=\"100%\"\n          viewBox={`0 0 ${VIEWBOX_WIDTH} ${VIEWBOX_HEIGHT}`}\n          preserveAspectRatio=\"none\"\n        >\n          <path\n            ref={pathRef}\n            d={`M 0 ${baseY} Q ${VIEWBOX_WIDTH / 2} ${baseY} ${VIEWBOX_WIDTH} ${baseY}`}\n            stroke=\"currentColor\"\n            strokeWidth={strokeWidth}\n            fill=\"none\"\n          />\n        </svg>\n      </div>\n    </div>\n  );\n}\n",
      "type": "registry:component"
    }
  ]
}
